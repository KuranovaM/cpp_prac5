# Основы объектно-ориентированного программирования в C++

## Основные концепции ООП:
- Классы
- Объекты
- Наследование
- Инкапсуляция
- Полиморфизм

## 1. Классы и объекты в C++

**Класс** — это пользовательский тип данных, который объединяет данные (переменные) и функции (методы) для работы с этими данными. Он служит шаблоном для создания объектов.

**Объект** — это экземпляр класса, конкретная реализация, которая хранит свои уникальные значения полей.

### Пример:
```cpp
#include <iostream>

class Car {
public:
    std::string brand;
    int speed;

    void drive() {
        std::cout << brand << " is driving at " << speed << " km/h\n";
    }
};

int main() {
    Car car1;  // Создание объекта класса Car
    car1.brand = "Toyota";
    car1.speed = 120;
    car1.drive();  // Вызов метода объекта

    return 0;
}
```

## 2. Конструкторы и деструкторы

Конструктор — это специальный метод класса, который вызывается автоматически при создании объекта и инициализирует его поля. Конструкторы могут быть с параметрами и без них (конструктор по умолчанию).

Деструктор — это метод, который автоматически вызывается при уничтожении объекта и освобождает ресурсы.

### Пример
```cpp
#include <iostream>

class Car {
public:
    std::string brand;
    int speed;

    // Конструктор
    Car(std::string b, int s) : brand(b), speed(s) {
        std::cout << "Car " << brand << " created\n";
    }

    // Деструктор
    ~Car() {
        std::cout << "Car " << brand << " destroyed\n";
    }

    void drive() {
        std::cout << brand << " is driving at " << speed << " km/h\n";
    }
};

int main() {
    Car car1("Toyota", 120);  // Вызов конструктора
    car1.drive();

    return 0;  // В конце программы вызовется деструктор
}
```
В этом примере конструктор Car инициализирует поля объекта brand и speed. Деструктор вызывается автоматически при завершении работы программы.

## 3. Наследование и работа с иерархиями классов

Наследование позволяет создавать новые классы на основе уже существующих. Производный класс наследует все поля и методы базового класса, но может добавлять новые поля, методы или переопределять (override) существующие.

```cpp
#include <iostream>

class Vehicle {
public:
    int speed;
    
    void drive() {
        std::cout << "Vehicle is driving at " << speed << " km/h\n";
    }
};

class Car : public Vehicle {
public:
    std::string brand;

    void drive() {  // Переопределение метода
        std::cout << brand << " is driving at " << speed << " km/h\n";
    }
};

class Bike : public Vehicle {
public:
    bool hasPedals;

    void ringBell() {
        std::cout << "Bike is ringing the bell!\n";
    }
};

int main() {
    Car car;
    car.brand = "Toyota";
    car.speed = 120;
    car.drive();  // Вызов метода Car

    Bike bike;
    bike.speed = 30;
    bike.hasPedals = true;
    bike.drive();  // Вызов метода Vehicle
    bike.ringBell();  // Вызов метода Bike

    return 0;
}
```
Здесь Car и Bike наследуют от базового класса Vehicle. Класс Car переопределяет метод drive(), а класс Bike добавляет новый метод ringBell().

## 4. Виртуальные функции и полиморфизм

Виртуальные функции и полиморфизм — это ключевые концепции объектно-ориентированного программирования (ООП) в C++. Они позволяют реализовать динамическое поведение объектов, которое зависит от их типа во время выполнения программы.

### Виртуальная функция

Виртуальная функция — это функция-член класса, объявленная с ключевым словом *virtual* в базовом классе, что позволяет производным классам переопределять эту функцию для предоставления специфической реализации.

### Пример

```cpp
#include <iostream>

class Animal {
public:
    virtual void speak() {  // Виртуальная функция
        std::cout << "Animal speaks\n";
    }
};

class Dog : public Animal {
public:
    void speak() override {  // Переопределение виртуальной функции
        std::cout << "Dog barks\n";
    }
};

class Cat : public Animal {
public:
    void speak() override {  // Переопределение виртуальной функции
        std::cout << "Cat meows\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->speak();  // Вызывает Dog::speak
    a2->speak();  // Вызывает Cat::speak

    delete a1;
    delete a2;

    return 0;
}
```

В этом примере класс Animal имеет виртуальную функцию speak(). Производные классы Dog и Cat переопределяют эту функцию, предоставляя свою реализацию. Когда функция speak() вызывается через указатель типа Animal*, C++ определяет, какую версию функции вызывать (из Dog или Cat) на основе фактического типа объекта, на который указывает указатель. Это поведение называется динамическим связыванием.

### Чисто виртуальная функция

Чисто виртуальная функция (или абстрактная функция) — это функция, которая не имеет реализации в базовом классе и должна быть переопределена в производных классах. Объявляется с помощью = 0 в базовом классе. Классы, содержащие чисто виртуальные функции, называются абстрактными и не могут быть инстанцированы напрямую.

### Пример с чисто виртуальной функцией и виртуальными деструкторами:
```cpp
#include <iostream>

class Animal {
public:
    virtual ~Animal() {  // Виртуальный деструктор
        std::cout << "Animal destructor called\n";
    }
    virtual void speak() const = 0;  // Чисто виртуальная функция
};

class Dog : public Animal {
public:
    void speak() const override {  // Переопределение чисто виртуальной функции
        std::cout << "Dog barks\n";
    }

    ~Dog() {  // Деструктор класса Dog
        std::cout << "Dog destructor called\n";
    }
};

class Cat : public Animal {
public:
    void speak() const override {  // Переопределение чисто виртуальной функции
        std::cout << "Cat meows\n";
    }

    ~Cat() {  // Деструктор класса Cat
        std::cout << "Cat destructor called\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->speak();  // Вызывает Dog::speak
    a2->speak();  // Вызывает Cat::speak

    delete a1;  // Правильно вызывает деструктор Dog, затем деструктор Animal
    delete a2;  // Правильно вызывает деструктор Cat, затем деструктор Animal

    return 0;
}
```
В этом примере класс Animal содержит чисто виртуальную функцию speak() и виртуальный деструктор. Классы Dog и Cat переопределяют чисто виртуальную функцию speak(). При удалении объектов через указатели типа Animal*, корректно вызываются деструкторы производных классов Dog и Cat, а затем деструктор базового класса Animal.

### Полиморфизм

Полиморфизм (от греч. "много форм") — это возможность функции обрабатывать объекты разных типов через единый интерфейс. В контексте виртуальных функций полиморфизм позволяет писать более гибкий и расширяемый код, в котором один и тот же код может работать с объектами разных классов.

### Полиморфизм бывает двух видов:

1 Компиляторный (статический) полиморфизм: реализуется с помощью перегрузки функций и шаблонов. Выбор нужной функции происходит во время компиляции.

2 Исполняемый (динамический) полиморфизм: реализуется через виртуальные функции. Выбор нужной функции происходит во время выполнения программы, в зависимости от типа объекта, на который указывает указатель или ссылка.

Пример выше демонстрирует динамический полиморфизм. Объекты типа Dog и Cat ведут себя по-разному при вызове функции speak(), несмотря на то, что они рассматриваются как объекты типа Animal. Это возможно благодаря тому, что speak() объявлена как виртуальная функция в базовом классе.

## Заключение

Виртуальные функции используются для создания функций, которые могут быть переопределены в производных классах.

Полиморфизм позволяет использовать указатели или ссылки на базовый класс для работы с объектами производных классов, обеспечивая гибкость и расширяемость кода.

Классы и объекты, конструкторы и деструкторы, наследование и полиморфизм — это фундаментальные концепции, на которых строятся гибкие системы на языке C++.


# Динамические структуры данных (свой vector)

Тема: Различия «C → C++», основы ООП на примере структуры **Point**, перегрузка операторов и работа с методами/конструкторами.

---

## 1) Динамический массив (аналог `std::vector`)

Идея: хранить элементы в непрерывном участке памяти и, когда места не хватает, **перевыделять** память с запасом (обычно ×2), копируя существующие элементы.

### Полезные термины
- **size (cur_sz)** — текущее число элементов.
- **capacity (mx_sz)** — вместимость массива (сколько элементов можно поместить без перевыделения).
- **amortized O(1)** — «амортизированная» сложность добавления `push_back`: редкие дорогие расширения компенсируются множеством дешёвых вставок.

### 1.1. Вариант C‑style, через `malloc/free`
> Демонстрационный код — в современном C++ лучше использовать `new[]/delete[]` или `std::vector`, но принцип здесь хорошо виден.

**main_02_01.cpp**
```cpp
struct dyn_arr {
    int* arr;      // данные
    int  mx_sz;    // capacity
    int  cur_sz;   // size

    dyn_arr() {
        arr    = (int*)malloc(4 * sizeof(int));
        mx_sz  = 4;
        cur_sz = 0;
    }

    ~dyn_arr() { free(arr); }

    void push_back(int x) {
        if (cur_sz < mx_sz) { arr[cur_sz++] = x; return; }
        // нет места — расширяем в 2 раза
        int* narr = (int*)malloc(2 * mx_sz * sizeof(int));
        for (int i = 0; i < mx_sz; ++i) narr[i] = arr[i];
        mx_sz *= 2;
        free(arr);
        arr = narr;
        arr[cur_sz++] = x;
    }

    void pop_back() { if (cur_sz > 0) --cur_sz; }

    int& operator[](int i) {
        if (i < 0 || i >= cur_sz) { printf("index out of range\n"); exit(1); }
        return arr[i];
    }

    int size() const { return cur_sz; }
    int capacity() const { return mx_sz; }
};
```

Использование:
```cpp
dyn_arr a;        // [ ]
a.push_back(2);   // [2]
a.push_back(5);   // [2, 5]
a.pop_back();     // [2]
a[0] = 42;        // [42]
```

### 1.2. «Чистый» C++‑вариант (`new[]/delete[]`, правило «трёх/пяти»)

> Если класс управляет ресурсом (сырая память), нужно корректно определить **деструктор, копирование и присваивание**. В идеале — ещё и перемещение (C++11+) для эффективности.

---

## 🔹 Что это вообще

В C++ если класс **управляет ресурсами** (например, динамической памятью, файлом, сокетом), то часто нужно явно определить специальные методы, чтобы правильно копировать/удалять объект.

Эти специальные методы называются **«big five»**:

1. **Деструктор**

   ```cpp
   ~ClassName();
   ```

   Освобождает ресурс при уничтожении объекта.

2. **Копирующий конструктор**

   ```cpp
   ClassName(const ClassName& other);
   ```

   Создаёт новый объект как копию другого.

3. **Оператор копирующего присваивания**

   ```cpp
   ClassName& operator=(const ClassName& other);
   ```

   Присваивает одному объекту содержимое другого (уже существующего).

4. **Перемещающий конструктор** (C++11+)

   ```cpp
   ClassName(ClassName&& other);
   ```

   Переносит ресурсы из временного объекта (cheap move вместо дорогой копии).

5. **Оператор перемещающего присваивания** (C++11+)

   ```cpp
   ClassName& operator=(ClassName&& other);
   ```

   То же самое, но для присваивания.

---

## 🔹 Зачем это нужно

Если есть **сырой ресурс** (например, `int* data_`), и не написать эти методы, то компилятор сгенерирует поверхностные (shallow copy) — скопирует только указатель. В итоге:

* два объекта будут думать, что владеют одним и тем же ресурсом;
* при уничтожении оба вызовут `delete[]` → **двойное освобождение** → ошибка.

**Правило пяти** говорит:
➡️ если нужен хоть один из этих методов (например, деструктор), почти наверняка нужны все остальные четыре.

## 🔹 Если ресурсами не управляешь

Если в классе **нет голых указателей** или других «ручных» ресурсов, то правило пяти можно игнорировать. Современный C++ рекомендует использовать **RAII-обёртки** (`std::vector`, `std::string`, `std::unique_ptr`), и тогда вообще не нужно писать эти методы.

---

**main_02_02.cpp**
```cpp
#include <stdexcept>
#include <algorithm>

class DynArr {
    int* data_  = nullptr;
    int  sz_    = 0;   // size
    int  cap_   = 0;   // capacity

    void grow() {
        int new_cap = std::max(1, cap_ * 2);
        int* nd = new int[new_cap];
        for (int i = 0; i < sz_; ++i) nd[i] = data_[i];
        delete[] data_;
        data_ = nd;
        cap_  = new_cap;
    }

public:
    DynArr() = default;

    ~DynArr() { delete[] data_; }

    // Копирующий конструктор
    DynArr(const DynArr& o) : data_(nullptr), sz_(o.sz_), cap_(o.cap_) {
        if (cap_) data_ = new int[cap_];
        for (int i = 0; i < sz_; ++i) data_[i] = o.data_[i];
    }

    // Копирующее присваивание
    DynArr& operator=(const DynArr& o) {
        if (this == &o) return *this;
        int* nd = (o.cap_ ? new int[o.cap_] : nullptr);
        for (int i = 0; i < o.sz_; ++i) nd[i] = o.data_[i];
        delete[] data_;
        data_ = nd; sz_ = o.sz_; cap_ = o.cap_;
        return *this;
    }

    // Перемещение (ускоряет возврат временных значений)
    DynArr(DynArr&& o) noexcept : data_(o.data_), sz_(o.sz_), cap_(o.cap_) {
        o.data_ = nullptr; o.sz_ = o.cap_ = 0;
    }
    DynArr& operator=(DynArr&& o) noexcept {
        if (this != &o) {
            delete[] data_;
            data_ = o.data_; sz_ = o.sz_; cap_ = o.cap_;
            o.data_ = nullptr; o.sz_ = o.cap_ = 0;
        }
        return *this;
    }

    void push_back(int x) {
        if (sz_ == cap_) grow();
        data_[sz_++] = x;
    }

    void pop_back() { if (sz_ > 0) --sz_; }

    int& operator[](int i) {
        if (i < 0 || i >= sz_) throw std::out_of_range("index");
        return data_[i];
    }
    const int& operator[](int i) const {
        if (i < 0 || i >= sz_) throw std::out_of_range("index");
        return data_[i];
    }

    int  size() const { return sz_; }
    int  capacity() const { return cap_; }
    bool empty() const { return sz_ == 0; }
    void clear() { sz_ = 0; }
};
```

**Почему увеличение ×2?**  
Так достигается амортизированная сложность `push_back` **O(1)**: пусть перевыделение стоит `k`, но оно случается редко — в среднем на элемент затраты постоянные.

### 1.3. Сравнение с другими структурами

| Структура | Память | `push`/`pop` в конец | Вставка в середину | Доступ по индексу |
|---|---|---|---|---|
| `vector` (наш `DynArr`) | непрерывная | O(1) аморт. | O(n) | O(1) |
| `stack` (на базе vector) | непрерывная | O(1) | — | — |
| `queue` (часто «кольцевой буфер») | непрерывная | O(1) | — | — |
| `list` (двусвязный) | узлы | O(1) по итератору | O(1) по итератору | O(n) |

**Вывод:** если нужен быстрый произвольный доступ и частые добавления в конец — берём динамический массив. Если много вставок/удалений в середине — пригоден список (но хуже по кэш‑локальности).

---

## 2) «C → C++»: ООП, структуры/классы, методы и операторы

### 2.1. `struct` vs `class`
В C++ это почти одно и то же, различие по умолчанию: у `struct` члены **public**, у `class` — **private**. Методы/конструкторы/деструкторы допустимы в обоих случаях.

### 2.2. Пример: геометрическая точка `Point`

```cpp
#include <cmath>
#include <iostream>

struct Point {
    double x{0}, y{0};

    Point() = default;                    // конструктор по умолчанию
    Point(double a, double b) : x(a), y(b) {}

    double len() const {                  // длина вектора (const-метод)
        return std::sqrt(x*x + y*y);
    }

    void rot(double ang) {                // поворот на угол ang (в радианах)
        double nx = x * std::cos(ang) - y * std::sin(ang);
        double ny = x * std::sin(ang) + y * std::cos(ang);
        x = nx; y = ny;
    }

    Point operator+(const Point& b) const { // сложение как вектор
        return {x + b.x, y + b.y};
    }

    Point& operator+=(const Point& b) {
        x += b.x; y += b.y; return *this;
    }

    friend std::ostream& operator<<(std::ostream& os, const Point& p) {
        return os << '(' << p.x << ", " << p.y << ')';
    }
};

int main() {
    Point p1(3,4), p2(1,2);
    Point sum = p1 + p2;      // перегрузка +
    std::cout << sum << "\n"; // (4, 6)
    std::cout << p1.len() << "\n"; // 5
    p1.rot(3.14159265/2);     // поворот на 90°
    std::cout << p1 << "\n";  // (≈ -4, 3)
}
```

Ключевые моменты:
- **Конструкторы** и **инициализация через список** (`: x(a), y(b) {}`).
- **`const`‑корректность** у методов, которые не меняют объект.
- **Перегрузка операторов** как методы/друзья (например, `operator+`, `operator<<`).
- В реальном проекте стоит отделять интерфейс и реализацию, использовать `#pragma once`/include‑guards в заголовках.

---

## 3) Важные замечания и типичные ошибки

1. **Сырые указатели** — источник утечек и ошибок. В современном коде используйте `std::vector`, `std::unique_ptr`, `std::shared_ptr`.
2. **Смешивание `malloc/free` и `new/delete`** — нельзя. Если начинаете `new[]`, то и освобождайте `delete[]` (и наоборот).
3. **Правило трёх/пяти**: если нужен пользовательский деструктор, почти наверняка нужны копирующие/перемещающие операции.
4. **Проверка границ**: `operator[]` обычно *не* проверяет границы (в `std::vector`). Для безопасного доступа используют метод `at()` с выбросом исключения.
5. **Сложность операций**: знайте, где у вас O(1), а где O(n), чтобы выбирать правильную структуру под задачу.

---

# Задание попрактиковаться

[Перейти в контест](https://contest.cs.msu.ru/cgi-bin/new-client?contest_id=612) — Задачи: L02-*
