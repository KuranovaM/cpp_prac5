# Урок 5: Новые типы данных C++17. Обобщённое программирование и шаблоны

## Введение в новые типы данных C++17

С выходом C++17 в стандартную библиотеку были добавлены три новых типа данных: `std::optional`, `std::variant` и `std::any`. Они помогают разработчикам управлять неопределёнными или разнородными данными более безопасно и выразительно. Рассмотрим каждый тип по отдельности.


## **std::optional**
`std::optional` — это шаблонный тип, который может либо хранить значение, либо не хранить его вовсе (null-like состояние). Это удобно в тех случаях, когда функция или переменная может вернуть либо конкретное значение, либо отсутствие значения.

### **Пример синтаксиса и применения:**

```cpp
#include <optional>
#include <iostream>

std::optional<int> find(int value) {
    if (value > 0)
        return value;  // Возвращаем значение
    return std::nullopt;  // Отсутствие значения
}

int main() {
    std::optional<int> result = find(10);
    
    if (result)  // Проверка на наличие значения
        std::cout << "Value: " << *result << std::endl;
    else
        std::cout << "No value found" << std::endl;
}
```

### **Когда использовать:**
- Когда функция может не вернуть результат (например, поиск в базе данных, где результат может отсутствовать).
- В ситуациях, когда наличие или отсутствие значения должно быть явно указано (вместо использования `nullptr` или магических чисел вроде `-1`).

### **Плюсы:**
- Избегание неопределённого поведения при работе с отсутствующими значениями.
- Явный контроль над отсутствием результата.

---

## **std::variant**
`std::variant` — это тип-объединение (union-like тип), который может содержать одно значение из нескольких типов. Это похоже на `union`, но безопаснее, так как `std::variant` хранит информацию о том, какой тип данных он содержит в текущий момент.

### **Пример синтаксиса и применения:**

```cpp
#include <variant>
#include <iostream>

using VarType = std::variant<int, double, std::string>;

void printVariant(const VarType& v) {
    std::visit([](auto&& arg) { std::cout << arg << std::endl; }, v);
}

int main() {
    VarType v1 = 10;
    VarType v2 = 3.14;
    VarType v3 = "Hello";

    printVariant(v1);
    printVariant(v2);
    printVariant(v3);
}
```

### **Когда использовать:**
- Когда требуется хранить значение, которое может быть одного из нескольких типов.
- В случаях, когда используется замена старым `union`, но с более безопасной обработкой типов.
- Для создания API, где функции могут возвращать разные типы данных в зависимости от условий.

### **Плюсы:**
- Типобезопасность: в отличие от `union`, `std::variant` сохраняет тип данных и проверяет его во время выполнения.
- Возможность обрабатывать различные типы с помощью `std::visit`, что упрощает код.

---

## **std::any**
`std::any` — это тип, который может хранить значения любого типа. Это аналог контейнера для "любой" переменной, который может использоваться для динамического хранения данных. При этом тип данных известен только во время выполнения.

### **Пример синтаксиса и применения:**

```cpp
#include <any>
#include <iostream>
#include <string>

void printAny(const std::any& a) {
    if (a.type() == typeid(int)) {
        std::cout << "int: " << std::any_cast<int>(a) << std::endl;
    } else if (a.type() == typeid(double)) {
        std::cout << "double: " << std::any_cast<double>(a) << std::endl;
    } else if (a.type() == typeid(std::string)) {
        std::cout << "string: " << std::any_cast<std::string>(a) << std::endl;
    }
}

int main() {
    std::any a = 10;
    printAny(a);

    a = 3.14;
    printAny(a);

    a = std::string("Hello");
    printAny(a);
}
```

### **Когда использовать:**
- Когда необходимо хранить данные любого типа, и тип данных известен только во время выполнения.
- В ситуациях, когда система должна быть гибкой и поддерживать разные типы данных (например, в конфигурационных системах, сериализации данных, универсальных контейнерах).

### **Плюсы:**
- Позволяет хранить объекты любого типа.
- Обеспечивает безопасное преобразование типов через `std::any_cast` с проверкой типов.

### **Минусы:**
- Невозможно использовать без динамического приведения типов (`std::any_cast`).
- Более сложный в использовании по сравнению с `std::variant`, если количество возможных типов невелико.

---

## Введение в обобщённое программирование

Обобщённое программирование — это стиль программирования, в котором разрабатываются алгоритмы и структуры данных, применимые к широкому спектру типов данных. Одним из основных инструментов обобщённого программирования в C++ являются **шаблоны**. Они позволяют писать универсальный код, который можно адаптировать к различным типам данных, что повышает гибкость, переиспользуемость и эффективность программ.

Этот урок познакомит вас с основами шаблонов в C++: как их использовать для создания шаблонных функций и классов, как специализировать шаблоны и как применять метапрограммирование для создания сложных решений на основе шаблонов.

Также мы начнем изучать thread и рассмотрим основные проблемы при создании мультипоточных приложений.

---

### 1. Основы шаблонов: функции и классы

Шаблоны в C++ делятся на два основных типа: **шаблоны функций** и **шаблоны классов**.

#### 1.1. Шаблоны функций

Шаблон функции позволяет определять функцию, которая может работать с различными типами данных без дублирования кода. Вместо того, чтобы писать несколько версий функции для каждого типа, мы определяем одну функцию, которая работает с параметризованным типом.

Пример шаблона функции:

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

Здесь `template <typename T>` сообщает компилятору, что `T` — это тип, который будет определён при вызове функции. В этом примере функция `max` может принимать параметры любого типа, например, `int`, `double`, `char` и т.д.

Использование шаблонной функции:

```cpp
int main() {
    int a = 5, b = 10;
    double x = 5.5, y = 3.3;

    std::cout << max(a, b) << std::endl;  // выводит 10
    std::cout << max(x, y) << std::endl;  // выводит 5.5
    return 0;
}
```

#### 1.2. Шаблоны классов

Шаблон класса работает аналогично шаблону функции, но применяется для создания универсальных классов. Шаблоны классов полезны, когда нужно создать классы, способные работать с различными типами данных.

Пример шаблона класса:

```cpp
template <typename T>
class Box {
private:
    T value;
public:
    Box(T v) : value(v) {}
    T getValue() {
        return value;
    }
};
```

Этот шаблон класса `Box` может хранить значение любого типа и предоставляет метод `getValue()` для доступа к этому значению.

Использование шаблона класса:

```cpp
int main() {
    Box<int> intBox(123);
    Box<double> doubleBox(45.67);

    std::cout << intBox.getValue() << std::endl;  // выводит 123
    std::cout << doubleBox.getValue() << std::endl;  // выводит 45.67
    return 0;
}
```

---

### 2. Специализация шаблонов и её использование

Иногда необходимо создать специальную версию шаблона для работы с определённым типом данных. Для этого используется **специализация шаблонов**. В C++ есть два вида специализаций: **полная** и **частичная**.

#### 2.1. Полная специализация

Полная специализация позволяет создать специализированную реализацию шаблона для конкретного типа. Например, можно создать шаблон функции, которая будет работать по-особому с типом `char`.

Пример полной специализации шаблона функции:

```cpp
template <>
char max<char>(char a, char b) {
    std::cout << "Специальная версия для char" << std::endl;
    return (a > b) ? a : b;
}
```

Здесь мы указали, что для типа `char` будет использоваться своя версия функции `max`.

#### 2.2. Частичная специализация

Частичная специализация применяется только к шаблонам классов. Она позволяет специализировать класс только для части типов, сохраняя общую реализацию для остальных.

Пример частичной специализации:

```cpp
template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;
    Pair(T1 f, T2 s) : first(f), second(s) {}
};

// Частичная специализация для случая, когда оба типа одинаковы
template <typename T>
class Pair<T, T> {
public:
    T first;
    T second;
    Pair(T f, T s) : first(f), second(s) {}
    void print() {
        std::cout << "Оба элемента одинаковы: " << first << ", " << second << std::endl;
    }
};
```

Здесь шаблон класса `Pair` в частично специализированной версии применим, если оба параметра типа одинаковы. 

---

### 3. Метапрограммирование с шаблонами

**Метапрограммирование** — это стиль программирования, в котором программы создают другие программы на этапе компиляции. Шаблоны C++ поддерживают метапрограммирование, позволяя производить вычисления на этапе компиляции, тем самым уменьшая накладные расходы времени выполнения.

Одним из популярных примеров метапрограммирования в C++ является вычисление факториала на этапе компиляции с помощью шаблонов.

Пример:

```cpp
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

// Специализация для случая N = 0
template <>
struct Factorial<0> {
    static const int value = 1;
};

int main() {
    std::cout << "Факториал 5: " << Factorial<5>::value << std::endl;  // выводит 120
    return 0;
}
```

Здесь мы используем рекурсивные шаблоны для вычисления факториала на этапе компиляции. Шаблон `Factorial<N>` рекурсивно умножает `N` на значение факториала `N - 1`, пока не достигнет базового случая `N = 0`.

#### Преимущества метапрограммирования:

1. **Вычисления на этапе компиляции**: Оптимизация времени выполнения за счёт предварительных вычислений.
2. **Сокращение дублирования кода**: Возможность автоматизировать создание кода.
3. **Безопасность типов**: Метапрограммирование позволяет создавать обобщённые алгоритмы, которые проверяются на этапе компиляции, уменьшая вероятность ошибок во время выполнения.

---

### Заключение

Шаблоны в C++ являются мощным инструментом, позволяющим реализовывать обобщённое программирование. Вы научились создавать шаблонные функции и классы, узнали о специализации шаблонов и познакомились с метапрограммированием с использованием шаблонов. Эти концепции позволяют писать более гибкий и эффективный код, который можно адаптировать к различным задачам и типам данных.

# Домашнее задание

Задачи L05-*