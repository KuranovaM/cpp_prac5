Урок 4: Пространства имен и управление зависимостями

## 1. Создание и использование пространств имен

### 1.1. Что такое пространство имен?
Пространство имен (namespace) в C++ используется для организации кода и предотвращения конфликтов имен. Оно позволяет сгруппировать функции, классы, переменные и другие идентификаторы, чтобы избежать их коллизий, когда одинаковые имена используются в разных частях программы.

### 1.2. Синтаксис объявления пространства имен
Для создания пространства имен используется ключевое слово `namespace`, за которым следует имя пространства и блок кода в фигурных скобках. Например:

```cpp
namespace MyNamespace {
    int variable = 10;
    void myFunction() {
        // тело функции
    }
}
```

В этом примере `variable` и `myFunction` принадлежат пространству имен `MyNamespace`.

### 1.3. Доступ к элементам пространства имен
Для доступа к элементам пространства имен используется оператор `::` (оператор разрешения области видимости). Например:

```cpp
int value = MyNamespace::variable;
MyNamespace::myFunction();
```

### 1.4. Директива `using`
Чтобы упростить доступ к элементам пространства имен, можно использовать директиву `using`:

```cpp
using namespace MyNamespace;
variable = 20;
myFunction();
```

Это приводит к тому, что все элементы пространства имен `MyNamespace` становятся доступными без явного указания.

### 1.5. Вложенные пространства имен
Пространства имен могут быть вложенными:

```cpp
namespace OuterNamespace {
    namespace InnerNamespace {
        void innerFunction() {
            // тело функции
        }
    }
}
```

Для доступа к `innerFunction` необходимо использовать полное имя:

```cpp
OuterNamespace::InnerNamespace::innerFunction();
```

### 1.6. Анонимные пространства имен
Анонимные пространства имен используются для ограничения видимости элементов в пределах одного файла:

```cpp
namespace {
    int hiddenVariable = 100;
}
```

Элементы внутри анонимного пространства имен доступны только в пределах текущего файла, что позволяет избежать их конфликта с элементами из других файлов.

## 2. Понимание и использование заголовочных файлов

### 2.1. Что такое заголовочные файлы?
Заголовочные файлы (.h или .hpp) в C++ содержат объявления классов, функций и переменных, которые можно использовать в разных исходных файлах. Они помогают разделять интерфейс и реализацию.

### 2.2. Преимущества использования заголовочных файлов
- **Разделение интерфейса и реализации**: Заголовочные файлы содержат только объявления, а реализация находится в отдельных файлах (.cpp).
- **Управление зависимостями**: Позволяют избегать избыточного повторного написания кода.
- **Упрощение поддержки и модульности**: Код становится более читаемым и удобным для сопровождения.

### 2.3. Структура заголовочного файла
Обычно заголовочный файл включает:
- Защитные макросы (или `#pragma once`).
- Объявления классов, функций и переменных.
- Необходимые директивы `#include`.

Пример заголовочного файла `MyClass.h`:

```cpp
#ifndef MYCLASS_H
#define MYCLASS_H

#include <iostream>

class MyClass {
public:
    void printMessage();
};

#endif // MYCLASS_H
```

## 3. Применение `#include`, `#define`, `#pragma once`

### 3.1. Директива `#include`
Директива `#include` используется для включения содержимого одного файла в другой. Различают два типа включений:
- **Системные заголовочные файлы**: Включаются с использованием угловых скобок `< >`, например: `#include <iostream>`.
- **Пользовательские заголовочные файлы**: Включаются с использованием кавычек `" "`, например: `#include "MyClass.h"`.

Системные файлы ищутся в стандартных директориях компилятора, а пользовательские — в директориях проекта.

### 3.2. Директива `#define`
Директива `#define` используется для определения макросов — именованных констант или текстовых замен:

```cpp
#define PI 3.14159
#define SQUARE(x) ((x) * (x))
```

Макросы заменяются компилятором на соответствующий текст на этапе предварительной обработки. Это может помочь уменьшить дублирование кода, но стоит использовать их с осторожностью, так как они могут затруднить отладку.

### 3.3. Директива `#pragma once`
`#pragma once` — это альтернатива защитным макросам в заголовочных файлах. Она предотвращает множественное включение одного и того же заголовочного файла:

```cpp
#pragma once

class MyClass {
    // Объявления
};
```

Она проще и удобнее защитных макросов, так как не требует создания уникальных имен для макросов.

### 4. Организация кода и управление зависимостями в больших проектах

При работе над большими проектами с множеством файлов и компонентов важно организовывать код таким образом, чтобы минимизировать зависимости и улучшить читаемость и поддержку проекта. В этом разделе мы рассмотрим некоторые рекомендации и паттерны для управления зависимостями и организацией кода.

#### 4.1. Разделение на модули

Одним из ключевых принципов при разработке больших проектов является разделение кода на модули. Модуль может представлять собой логически связанный набор классов и функций, отвечающих за конкретный функционал.

- **Модульность** позволяет изменять и тестировать отдельные компоненты без необходимости вносить изменения в весь проект.
- **Инкапсуляция**: Модули скрывают реализацию и предоставляют интерфейсы, что упрощает использование и тестирование.

Для каждого модуля следует создать:
- **Заголовочный файл** (.h), который содержит объявления классов, функций и переменных.
- **Файл реализации** (.cpp), где описана логика работы модуля.

Пример структуры проекта:

```
Project/
│
├── main.cpp
├── ModuleA/
│   ├── ModuleA.h
│   └── ModuleA.cpp
└── ModuleB/
    ├── ModuleB.h
    └── ModuleB.cpp
```

#### 4.2. Управление зависимостями

Когда модули используют функциональность друг друга, важно контролировать зависимости между ними, чтобы избежать циклических зависимостей и излишних включений заголовочных файлов.

- **Использование `#include` только в необходимости**: Включайте заголовочные файлы только в тех случаях, когда они действительно необходимы.
- **Использование предварительных объявлений** (forward declarations): Если в заголовочном файле нужно сослаться на тип, объявленный в другом модуле, можно использовать предварительное объявление.

```cpp
// ModuleA.h
#ifndef MODULEA_H
#define MODULEA_H

class ModuleB;  // Предварительное объявление класса

class ModuleA {
public:
    void setModuleB(ModuleB* b);
private:
    ModuleB* moduleB;
};

#endif // MODULEA_H
```

- **Избегание циклических зависимостей**: Структурируйте код так, чтобы модули не зависели друг от друга напрямую. Если это невозможно, рассмотрите возможность использования интерфейсов или абстрактных классов.

#### 4.3. Пример использования интерфейсов для управления зависимостями

Интерфейсы (абстрактные классы) позволяют разделить интерфейс и реализацию, что упрощает замену реализаций и тестирование. Например:

```cpp
// IModuleB.h
#ifndef IMODULEB_H
#define IMODULEB_H

class IModuleB {
public:
    virtual void doSomething() = 0;
    virtual ~IModuleB() = default;
};

#endif // IMODULEB_H
```

Теперь `ModuleA` может работать с интерфейсом `IModuleB`, не зная о конкретной реализации `ModuleB`.

```cpp
// ModuleA.h
#ifndef MODULEA_H
#define MODULEA_H

#include "IModuleB.h"

class ModuleA {
public:
    void setModuleB(IModuleB* b);
    void useModuleB();
private:
    IModuleB* moduleB;
};

#endif // MODULEA_H
```

```cpp
// ModuleA.cpp
#include "ModuleA.h"

void ModuleA::setModuleB(IModuleB* b) {
    moduleB = b;
}

void ModuleA::useModuleB() {
    if (moduleB) {
        moduleB->doSomething();
    }
}
```

Такое использование интерфейсов помогает управлять зависимостями между модулями и упрощает замену и тестирование компонентов.

#### 4.4. Использование пространств имен для больших проектов

Для больших проектов рекомендуется создавать иерархию пространств имен, чтобы избежать конфликтов имен и организовать код. Например, если в проекте много модулей, можно использовать такую структуру пространств имен:

```cpp
namespace Project {
    namespace ModuleA {
        class ClassA {
            // ...
        };
    }

    namespace ModuleB {
        class ClassB {
            // ...
        };
    }
}
```

Теперь доступ к классам осуществляется через полный путь:

```cpp
Project::ModuleA::ClassA objectA;
Project::ModuleB::ClassB objectB;
```

## 5. Инструменты сборки и управление зависимостями

Для больших проектов важно использовать инструменты сборки, такие как CMake, Makefile или системы управления проектами в IDE, чтобы автоматически собирать проект и управлять зависимостями.

### 5.1. Использование CMake

CMake — мощный инструмент для управления сборкой проектов. Он позволяет автоматически генерировать Makefile или проекты для разных IDE.

CMake может генерировать файлы `Makefile`, но не только их. CMake — это кроссплатформенный инструмент для автоматической генерации файлов сборки, таких как `Makefile` для `make`, проекты для Visual Studio, Xcode и многие другие. Суть CMake в том, чтобы предоставить единый способ описания процесса сборки, который затем может быть преобразован в формат, соответствующий нужному инструменту сборки на конкретной платформе.

#### Как работает CMake?

1. **Создание CMakeLists.txt**: Сначала создаётся файл `CMakeLists.txt`, в котором указываются исходные файлы, заголовочные файлы, необходимые библиотеки и параметры компиляции.

2. **Генерация файлов сборки**: На основе `CMakeLists.txt` CMake генерирует файлы сборки, которые используются инструментами на конкретной платформе. Это могут быть:
   - `Makefile` для UNIX-подобных систем (Linux, macOS и т. д.).
   - Проекты для Visual Studio (`.sln` и `.vcxproj`).
   - Проекты для Xcode.
   - Файлы для Ninja (`build.ninja`).
   - И многие другие.

3. **Сборка проекта**: После генерации файлов сборки используется соответствующий инструмент для компиляции и линковки программы. Например, в случае `Makefile` это будет команда `make`.

#### Пример 1 использования CMake для генерации Makefile

Предположим, у нас есть простая структура проекта (смотри папку **cmake_example**):

```
project/
├── CMakeLists.txt
└── main.cpp
```

Содержимое `main.cpp`:

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, CMake!" << std::endl;
    return 0;
}
```

Содержимое `CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.10)
project(HelloCMake)

# Указываем стандарт C++
set(CMAKE_CXX_STANDARD 17)

# Добавляем исполняемый файл
add_executable(HelloCMake main.cpp)
```

Теперь, чтобы создать `Makefile` на UNIX-подобной системе, выполняем следующие команды в терминале:

```bash
# Создаем директорию для сборки
mkdir build
cd build

# Генерируем Makefile
cmake ..

# Запускаем сборку
make
```

#### Результат

- Команда `cmake ..` прочитает `CMakeLists.txt` и сгенерирует `Makefile` в папке `build`.
- Команда `make` использует `Makefile` для компиляции и линковки проекта.

Таким образом, CMake не выполняет сборку напрямую, а лишь генерирует файлы, которые будут использоваться инструментами сборки, такими как `make`, для компиляции проекта.

#### Пример 2 с несколькими модулями

Пример CMakeLists.txt для проекта с несколькими модулями (смотри папку **cmake_example_module_A_B**):

```cmake
cmake_minimum_required(VERSION 3.10)
project(MyProject)

# Установка стандартов C++
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Добавление поддиректорий с модулями
add_subdirectory(ModuleA)
add_subdirectory(ModuleB)

# Главный исполняемый файл
add_executable(MyProject main.cpp)

# Линковка модулей
target_link_libraries(MyProject ModuleA ModuleB)
```

Аналогично **Примеру 1**, чтобы создать `Makefile`:

```bash
# Создаем директорию для сборки
mkdir build
cd build

# Генерируем Makefile
cmake ..

# Запускаем сборку
make
```

- Команда `cmake ..` - сгенерирует `Makefile` в папке `build`.
- Команда `make` - компиляции и линковки проекта.

#### Что важно в Примере 2

##### Верхний `CMakeLists.txt`:

* `option(...)` — позволяет включать/выключать сборку модулей. Например:

  ```bash
  cmake -DBUILD_MODULE_A=OFF ..
  ```

  выключит модуль A.
* `add_subdirectory(ModuleA)` и `add_subdirectory(ModuleB)` — переход внутрь папок модулей, чтобы там собрать библиотеку.
* `add_definitions(-DHAVE_MODULE_A)` — добавляет макрос компиляции. В коде проверяется `#ifdef HAVE_MODULE_A` и подключаются заголовки только если модуль собран.
* `target_link_libraries(MyProject ModuleA ModuleB)` — прикрепляет библиотеки к главному исполняемому файлу.
* `install(...)` — описывает, как устанавливать (раскладывать) исполняемый файл, библиотеки и заголовки при установке проекта (`make install`).

---

##### `ModuleA/CMakeLists.txt`

```cmake
add_library(ModuleA ModuleA.cpp)
target_include_directories(ModuleA PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

* `add_library(ModuleA ModuleA.cpp)` — создаёт библиотеку `ModuleA` из исходника `ModuleA.cpp`.
* `target_include_directories(ModuleA PUBLIC ...)` — сообщает, что при подключении этой библиотеки в других местах (`main.cpp`), компилятор должен искать заголовки (`ModuleA.h`) в текущей папке `ModuleA/`.



##### `ModuleB/CMakeLists.txt`

```cmake
add_library(ModuleB ModuleB.cpp)
target_include_directories(ModuleB PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
```

Аналогично модулю A:

* создаётся библиотека `ModuleB` из `ModuleB.cpp`,
* добавляется путь к заголовкам (`ModuleB.h`).


##### Логика:

* Сначала всегда печатается `"Hello main"`.
* Если модуль A подключён (`-DHAVE_MODULE_A`), вызывается `ModuleAhello()`.
* Если модуль B подключён, вызывается `ModuleBhello()`.

---

##### Как работает сборка

1. `cmake ..`:

   * Читает корневой `CMakeLists.txt`.
   * Если включён `BUILD_MODULE_A` → заходит в `ModuleA/CMakeLists.txt`, собирает библиотеку `ModuleA`.
   * Аналогично для `ModuleB`.
   * Создаёт цель `MyProject` и линкует туда нужные библиотеки.

2. `make`:

   * Сначала собирает модули (`ModuleA`, `ModuleB`).
   * Потом компилирует `main.cpp`, учитывая флаги `-DHAVE_MODULE_A` / `-DHAVE_MODULE_B`.
   * На этапе линковки соединяет всё в один бинарник.

---

##### Что будет на практике

* Если собрать с обоими модулями (`BUILD_MODULE_A=ON`, `BUILD_MODULE_B=ON`):

```
Hello main
Hello from Module A 
Hello from Module B
```

* Если отключить модуль A:

```
Hello main
Hello from Module B
```

* Если отключить оба:

```
Hello main
```

#### Пример 3 — использование внешней JSON-библиотеки

Теперь сделаем проект, который подключает библиотеку [**nlohmann/json**](https://github.com/nlohmann/json) для работы с JSON.
Эта библиотека подключается напрямую через CMake (с помощью `FetchContent`) и используется в коде.

---

##### Структура проекта (**cmake_example_json**)

```
project/
├── CMakeLists.txt
└── main.cpp
```

---

##### Сборка и запуск

```bash
mkdir build
cd build
cmake ..
make
./JsonFetchExample
```

---

### Что происходит

1. **`FetchContent`** в CMake скачивает исходники библиотеки `nlohmann/json` прямо из GitHub и делает доступной цель `nlohmann_json::nlohmann_json`.
2. **`target_link_libraries`** подключает эту библиотеку к нашему проекту.
3. В `main.cpp` подключаем заголовочный файл `<nlohmann/json.hpp>` и создаём JSON-объект.
4. Функция `dump(4)` печатает JSON красиво с четырьмя пробелами отступа.


## 6. JSON библотека

### 6.1. **Создание JSON-объектов**

`nlohmann/json` позволяет легко создавать JSON-объекты с помощью синтаксиса, схожего с инициализацией стандартных контейнеров.

#### Пример создания JSON-объекта:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    // Создание JSON-объекта
    json j = {
        {"name", "Alice"},
        {"age", 25},
        {"is_active", true},
        {"skills", {"C++", "Python", "Java"}}
    };

    std::cout << j.dump(4) << std::endl;  // Вывод JSON с отступами
    return 0;
}
```

**Результат:**
```json
{
    "age": 25,
    "is_active": true,
    "name": "Alice",
    "skills": [
        "C++",
        "Python",
        "Java"
    ]
}
```

#### **Методы для работы с JSON-объектами:**

- **`j["key"]`**: Доступ к значению по ключу.
- **`j.at("key")`**: Альтернативный безопасный способ доступа (выбрасывает исключение при отсутствии ключа).
- **`j.size()`**: Возвращает размер JSON-объекта или массива.
- **`j.contains("key")`**: Проверяет наличие ключа в объекте.
- **`j.dump()`**: Преобразует объект JSON в строку. Можно указать отступы для более читабельного вывода, например `j.dump(4)`.

### 6.2. **Парсинг JSON-строки**

Библиотека поддерживает удобный синтаксис для парсинга JSON из строк.

#### Пример:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    // JSON-строка
    std::string json_string = R"(
        {
            "name": "Bob",
            "age": 30,
            "is_active": false,
            "skills": ["JavaScript", "HTML", "CSS"]
        }
    )";

    // Парсинг строки в JSON-объект
    json j = json::parse(json_string);

    std::cout << "Name: " << j["name"] << std::endl;
    std::cout << "Age: " << j["age"] << std::endl;
    std::cout << "Is Active: " << j["is_active"] << std::endl;

    return 0;
}
```

**Результат:**
```
Name: Bob
Age: 30
Is Active: false
```

####  **Обратите внимание** Сырая строка

`R` в начале строки — это обозначение **сырой строки** (raw string literal) в C++. Такой синтаксис позволяет включать специальные символы (например, обратные слэши `\`, кавычки `"`, символы новой строки) без необходимости экранировать их.

В обычной строке C++ нужно экранировать специальные символы с помощью обратного слэша:
```cpp
std::string normal_string = "This is a \"quoted\" string with a newline character \\n.";
```

Сырая строка (raw string) позволяет писать строку напрямую без экранирования:
```cpp
std::string raw_string = R"(This is a "quoted" string with a newline character \n.)";
```

Особенности сырой строки:
1. Строка начинается с `R"(` и заканчивается `)"`.
2. Все символы внутри этих скобок трактуются буквально, без экранирования.
3. Сырой строкой удобно задавать многострочные литералы, такие как JSON, регулярные выражения или файлы с кодом.

В твоем примере:
```cpp
std::string json_string = R"(
        {
            "name": "Bob",
            "age": 30,
            "is_active": false,
            "skills": ["JavaScript", "HTML", "CSS"]
        }
    )";
```
Используется сырая строка для JSON, чтобы избежать экранирования кавычек и символов новой строки. Это делает код более читабельным и проще в написании, особенно при работе с многострочными текстами.

### 6.3. **Доступ и изменение значений**

Доступ к значениям осуществляется с помощью операторов квадратных скобок, а также можно изменять значения в объекте.

#### Пример:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    json j = {
        {"name", "Alice"},
        {"age", 25},
        {"is_active", true}
    };

    // Доступ к значениям
    std::string name = j["name"];
    int age = j["age"];
    bool is_active = j["is_active"];

    // Изменение значений
    j["age"] = 26;
    j["is_active"] = false;

    std::cout << j.dump(4) << std::endl;
    return 0;
}
```

**Результат:**
```json
{
    "age": 26,
    "is_active": false,
    "name": "Alice"
}
```

### 6.4. **Работа с массивами**

JSON-массивы в библиотеке представлены как обычные списки или векторы. Вы можете создавать массивы и обращаться к их элементам по индексу.

#### Пример работы с массивами:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    // JSON-массив
    json j = {
        {"languages", {"C++", "Python", "PHP"}},
        {"scores", {85, 90, 78}}
    };

    // Доступ к элементам массива
    for (const auto& language : j["languages"]) {
        std::cout << "Language: " << language << std::endl;
    }

    // Изменение элементов массива
    j["scores"][0] = 95;  // Меняем оценку

    std::cout << j.dump(4) << std::endl;

    return 0;
}
```

**Результат:**
```json
{
    "languages": [
        "C++",
        "Python",
        "PHP"
    ],
    "scores": [
        95,
        90,
        78
    ]
}
```

### 6.5. **Сериализация (преобразование в строку)**

Для преобразования JSON-объекта обратно в строку используйте метод `dump()`. Можно указать параметр для отступов, чтобы получить форматированный JSON.

#### Пример:

```cpp
#include <iostream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    json j = {
        {"name", "Charlie"},
        {"age", 29},
        {"is_active", true}
    };

    // Преобразование JSON в строку
    std::string serialized = j.dump();      // Без отступов
    std::string pretty_serialized = j.dump(4);  // С отступами

    std::cout << "Serialized JSON: " << serialized << std::endl;
    std::cout << "Pretty JSON: " << pretty_serialized << std::endl;

    return 0;
}
```

### 6.6. **Обработка ошибок**

Если JSON-строка некорректна или содержимое неверно, библиотека выбросит исключение. Например, при неправильном формате строки в процессе парсинга:

```cpp
try {
    json j = json::parse("Invalid JSON String");
} catch (json::parse_error& e) {
    std::cerr << "Parsing error: " << e.what() << std::endl;
}
```

### 6.7. **Дополнительные возможности**

- **Проверка типов:** Для безопасной работы с JSON можно использовать методы `is_*`, например `is_string()`, `is_number()`, `is_boolean()` и т.д.
  
- **Проверка наличия ключа:** Метод `contains()` проверяет наличие ключа в JSON-объекте.
  
- **Итерирование по объекту:** Вы можете итерироваться по ключам и значениям JSON-объекта.

#### Пример:

```cpp
for (auto& [key, value] : j.items()) {
    std::cout << key << " : " << value << std::endl;
}
```

# Домашнее задание: AI-агент на базе `ai_agent_example`

## Цели

* Разобраться с примером `ai_agent_example` (C++17, CMake, OpenSSL, nlohmann/json).
* Научиться собирать и запускать проект.
* Спроектировать **своего** агента на базе примера.
* Оформить изменения в виде **pull request** + подготовить **README.md**.
* Кратко рассказать о работе на следующем уроке.

---

## Варианты идей (выберите одну или предложите свою)

1. **Чекер для ejudge**: агент получает условие/код, отправляет на проверку (или “эмулирует”), возвращает вердикт/подсказки.
2. **CLI-помощник**: агент отвечает на простые команды (help/todo/timer/summary).
3. **Продвинутый помощник**: несколько режимов (поиск идей, планировщик, резюме текста, генерация тестов).
4. **Проверка кода на ошибки**: агент анализирует текст C++/Python кода и выдает список возможных ошибок/рекомендаций.
5. **Оценка кода по критериям**: читабельность, стиль, сложность, теги (алгоритмы/структуры данных/паттерны).
6. **Цепочки запросов**: пайплайн из нескольких шагов (сначала суммаризация, потом генерация тестов, затем валидация).
7. **Мини “C++ компилятор-помощник”**: агент оценивает код, подсказывает флаги компиляции, генерирует CMakeList, выдает фиксы.
8. **СВОЯ ИДЕЯ** придумайте что-то еще...

> Можно комбинировать идеи. Главное — показать **ценность** и **работающую демонстрацию**.

---

## Что нужно сделать (шаги)

1. **Форкнуть** репозиторий с примером `ai_agent_example` (или взять выданный архив и залить в свой репозиторий).
1. Сборка примера:

   ```bash
   mkdir build && cd build
   cmake ..
   make -j
   ./ai_agent
   ```

   Убедитесь, что `config.json` и `prompt.json` читаются, запрос уходит, ответ парсится.

- **Ключ к АПИ необходимо получить отдельно**

1. **Спроектировать функциональность** вашего агента 
    Кратко описать в README.md

1. **Реализовать** логику:

   * Добавить свои методы/класс поверх `AiAgent` или изменить `main.cpp`.
   * При необходимости — дополнительный модуль (папка с `CMakeLists.txt`), свои `.h/.cpp`.
   * Не ломать существующий рабочий пример — лучше расширять.

1. **Подготовить демо**:

   * Сценарий запуска в терминале: пример команд и ожидаемый вывод.
   * Мини-набор тестовых входов (файлы в `examples/` или `tests/inputs/`).

1. **Pull Request**:

Создайте новую папку с вашим именем в уроке в папке (assignments/lesson04/ivanov/)

---

## Требования к коду и проекту

* C++17, сборка через CMake (не удаляйте поддержку macOS/Linux).
* Не хардкодить ключи в коде — **читаем из `config.json`**.
* Парсинг/генерация JSON — через **nlohmann/json**.
* Ошибки сети/парсинга — аккуратно обрабатывать (печать понятного сообщения).
* Код компилируется без ошибок/варнинги по возможности устраняйте.
* README понятный, чтобы посторонний мог собрать и запустить.

---

## Шаблон README.md (минимум)

````markdown
# <Название вашего агента>

## Идея
Коротко: какую задачу решает агент, для кого и зачем.

## Возможности
- Пункт 1
- Пункт 2
- ...

## Установка и сборка
```bash
git clone <ваш-репозиторий>
cd <папка>
mkdir build && cd build
cmake ..
make -j
````

## Настройка

`config.json` в корне:

```json
{
  "host": "ai-api.hurated.com",
  "port": "443",
  "api_key": "<ваш ключ>"
}
```

Промпт в `prompt.json`:

```json
"Ваш стартовый промпт сюда"
```

## Запуск

```bash
./ai_agent <опциональные аргументы>
# или примеры:
./ai_agent --mode check --file examples/code.cpp
```