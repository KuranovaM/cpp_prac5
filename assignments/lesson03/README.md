# Урок 3: Современные функции и улучшения в C++17

### Часть 1: `if constexpr` и inline функции

#### 1.1 `if constexpr`

`if constexpr` — это конструкция, добавленная в C++17, которая позволяет компилятору выполнять условие на этапе компиляции. Это улучшение помогает уменьшить количество ошибок в шаблонах и делает код более эффективным, потому что нежелательные ветки не компилируются, если условие известно на этапе компиляции.

##### Основные особенности:
- `if constexpr` используется в шаблонных функциях или коде, который можно выполнить на этапе компиляции.
- В отличие от обычного `if`, ветка кода, не прошедшая условие `if constexpr`, вообще не компилируется, а значит, возможные ошибки в ней не будут мешать компиляции.

##### Пример:

```cpp
template <typename T>
void print(T t) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Целочисленный тип: " << t << std::endl;
    } else {
        std::cout << "Не целочисленный тип: " << t << std::endl;
    }
}
```

Здесь, если `T` — целочисленный тип (например, `int` или `long`), будет скомпилирован первый блок, а если тип — нецелочисленный (например, `double` или `std::string`), будет скомпилирован второй блок.

#### 1.2 Inline-функции

В C++17 концепция inline-функций получила расширение. Теперь можно объявлять **inline переменные**. Ранее переменные, определённые в заголовочных файлах, требовали специальных указаний для корректной работы, чтобы не было множественных определений в разных единицах трансляции.

##### Основные моменты:
- `inline` теперь можно использовать не только с функциями, но и с переменными.
- Inline-функции и переменные полезны, когда требуется, чтобы их можно было определять в нескольких единицах трансляции без дублирования символов.

##### Пример inline переменной:

```cpp
inline int global_value = 10; // Может быть определена в заголовочном файле
```

Теперь эта переменная может быть объявлена в нескольких единицах трансляции без ошибок компоновки.

### Часть 2: Авто-определение типа (`auto`)

#### 2.1 `auto` для упрощения определения типов

`auto` — это механизм автоматического выведения типов, который появился еще в C++11, но в C++17 его применение стало ещё более удобным и распространённым. Он позволяет компилятору автоматически выводить тип переменной на основании выражения, присваиваемого переменной.

##### Преимущества `auto`:
- Упрощает чтение и написание кода, особенно когда типы сложные (например, итераторы или типы шаблонов).
- Снижает риск ошибок, связанных с несоответствием типов.

##### Пример:

```cpp
auto x = 10;       // x имеет тип int
auto y = 3.14;     // y имеет тип double
auto z = "Hello";  // z имеет тип const char*
```

Компилятор автоматически выводит тип переменной на основе инициализатора.

#### 2.2 `auto` и возвращаемый тип функций

Теперь `auto` можно использовать для указания возвращаемого типа функции, который компилятор будет выводить на основании возвращаемого значения.

##### Пример:

```cpp
auto add(int a, int b) {
    return a + b;  // Компилятор выводит, что возвращаемый тип — int
}
```

В случае более сложных функций это делает код более кратким и читабельным.

### Часть 3: Упрощение лямбда-выражений

#### Лямбда-выражения. Напоминание

Лямбда-выражения в C++ — это способ определения анонимных функций прямо в месте их использования. Они были введены в C++11 и позволяют создавать компактные и удобные функции, которые могут захватывать переменные из окружающего контекста. Вот как выглядит синтаксис лямбда-выражения в C++:

```cpp
[capture](parameters) -> return_type {
    // function body
}
```

Вот что означают различные части этого синтаксиса:

- **`[capture]`** — список захвата. Здесь указываются переменные, которые будут захвачены из внешнего контекста. Можно использовать:
  - `[]` — не захватывать ничего,
  - `[&]` — захватить все переменные по ссылке,
  - `[=]` — захватить все переменные по значению,
  - `[var]` — захватить конкретную переменную по значению,
  - `[&var]` — захватить конкретную переменную по ссылке.

- **`(parameters)`** — список параметров лямбда-функции (аналогично обычной функции).

- **`-> return_type`** — (опционально) тип возвращаемого значения. Если он не указан, компилятор сам определит его.

- **`{ ... }`** — тело лямбды, где вы пишете код функции.

Примеры:

1. Простое лямбда-выражение, не захватывающее никакие переменные:

    ```cpp
    auto printHello = []() {
        std::cout << "Hello, World!" << std::endl;
    };
    printHello(); // Вызов лямбда-функции
    ```

2. Лямбда-выражение с захватом переменной по значению:

    ```cpp
    int x = 10;
    auto addX = [x](int y) {
        return x + y;
    };
    std::cout << addX(5); // Вывод: 15
    ```

3. Лямбда-выражение с захватом переменной по ссылке:

    ```cpp
    int x = 10;
    auto incrementX = [&x]() {
        x++;
    };
    incrementX();
    std::cout << x; // Вывод: 11
    ```

Лямбда-выражения полезны в различных ситуациях, например, при работе с алгоритмами из стандартной библиотеки (например, `std::sort`), для реализации обратных вызовов, обработки событий и т.д.

#### 3.1 Лямбда-выражения с автоматическим выводом типов

Лямбда-выражения в C++17 были улучшены для большей гибкости и удобства. Теперь они могут использовать `auto` для параметров, что делает код более универсальным и уменьшает необходимость явного указания типов аргументов.

##### Пример:

```cpp
auto lambda = [](auto a, auto b) {
    return a + b;
};

std::cout << lambda(1, 2) << std::endl;        // Вывод: 3
std::cout << lambda(1.5, 2.5) << std::endl;    // Вывод: 4.0
```

Теперь лямбда может принимать любые типы данных (например, целые числа, числа с плавающей запятой) без явного указания типа в определении.

##### Замечание: «мини-шаблонные функции»

Благодаря параметрам с `auto` лямбду можно рассматривать как **маленькую шаблонную функцию**. Она сама подстраивается под типы аргументов, как если бы вы написали шаблон:

```cpp
template <typename T, typename U>
auto multiply(T a, U b) {
    return a * b;
}

// Эквивалентная лямбда
auto multiplyLambda = [](auto a, auto b) {
    return a * b;
};

std::cout << multiply(3, 4) << std::endl;           // 12 (int)
std::cout << multiplyLambda(2.5, 4.2) << std::endl; // 10.5 (double)
```

##### Eще Пример (использования в алгоритмах STL):

```cpp
std::vector<int> nums = {1, 2, 3, 4, 5};

// фильтрация: посчитаем, сколько чисел больше 3
int count = std::count_if(nums.begin(), nums.end(),
    [](int n) { return n > 3; });

std::cout << "Чисел больше 3: " << count << std::endl;
```

Без лямбды пришлось бы писать отдельную функцию.

#### 3.2 Захват по значению и по ссылке

Когда мы используем лямбда-выражение, очень часто нужно работать с переменными из внешнего контекста (например, из функции `main`). Для этого существует **список захвата** — первая часть лямбды в квадратных скобках.

В C++ переменные можно захватывать **по значению** (копия) или **по ссылке** (оригинал).

---

##### Захват по значению `[x]`

Если переменная захвачена **по значению**, то внутрь лямбды копируется её текущее значение.

```cpp
int x = 10;

auto f = [x]() {
    return x + 5; // работает с копией
};

std::cout << f() << std::endl; // 15
std::cout << x << std::endl;   // 10 (оригинал не изменился)
```

Здесь:

* внутри лямбды `x` — это копия, никак не связанная с внешним `x`;
* даже если внутри лямбды мы изменим `x`, оригинальная переменная останется неизменной.

---

##### Захват по ссылке `[&x]`

Если переменная захвачена **по ссылке**, то лямбда работает с оригиналом.

```cpp
int x = 10;

auto f = [&x]() {
    x += 5;      // изменяет настоящий x
    return x;
};

std::cout << f() << std::endl; // 15
std::cout << x << std::endl;   // 15 (оригинал изменился!)
```

Здесь:

* лямбда напрямую работает с переменной `x` снаружи;
* любое изменение внутри лямбды отражается на оригинальной переменной.

---

##### Захват всех переменных

* `[=]` — захватить все видимые переменные **по значению**.
* `[&]` — захватить все видимые переменные **по ссылке**.

```cpp
int a = 3, b = 7;

// всё по значению
auto f1 = [=]() { return a + b; };

// всё по ссылке
auto f2 = [&]() { a++; b++; return a + b; };

std::cout << f1() << std::endl; // 10 (копии a и b)
std::cout << f2() << std::endl; // 12 (a=4, b=8 изменены)
```

---

##### Когда что использовать?

* Захват **по значению** удобен, когда нужно «заморозить» состояние переменной на момент создания лямбды.
* Захват **по ссылке** полезен, когда нужно, чтобы лямбда напрямую работала с изменяемыми внешними данными.

#### 3.3 Захват всего контекста

Лямбда-выражения позволяют захватывать переменные из внешней области видимости, чтобы использовать их внутри тела функции. В C++11/C++14 это делалось с помощью `[=]` (захват всех по значению) и `[&]` (захват всех по ссылке).

В **C++17** добавилось ещё одно полезное расширение: **можно захватить весь контекст (все переменные)**, но при этом уточнить, какие именно переменные нужно захватить по ссылке или по значению.

Это делается с помощью записи вида:

```cpp
[=, &var]   // всё по значению, но var по ссылке
[&, var]    // всё по ссылке, но var по значению
```

Таким образом, можно задать «правило по умолчанию» и при этом явно исключить некоторые переменные.

##### Пример 1. Базовый захват с уточнением

```cpp
int a = 5, b = 10;

// Всё по значению, но b по ссылке
auto lambda = [=, &b]() {
    return a + b++;  // a скопирован, b изменяется напрямую
};

lambda();
std::cout << b << std::endl;  // b был изменён: 11
```

Здесь:

* `a` захвачен **по значению** → внутри лямбды у него есть своя копия, она не влияет на оригинал;
* `b` захвачен **по ссылке** → внутри лямбды мы изменяем настоящий `b`.

---

##### Пример 2. Обратный случай

```cpp
int a = 5, b = 10;

// Всё по ссылке, но a по значению
auto lambda = [&, a]() {
    b += 5;       // изменяет внешний b
    return a * 2; // использует копию a
};

std::cout << lambda() << std::endl; // Вывод: 10
std::cout << b << std::endl;        // Вывод: 15
```

Здесь:

* `b` захвачен **по ссылке** → изменяется оригинал;
* `a` захвачен **по значению** → в лямбде используется копия.

---

##### Пример 3. Удобство записи

Рассмотрим ситуацию: у нас есть несколько переменных, и мы хотим почти все использовать по значению, а только одну — по ссылке.

Вместо громоздкого:

```cpp
auto lambda = [a, c, d, &b]() { return a + b + c + d; };
```

в C++17 можно записать компактно:

```cpp
auto lambda = [=, &b]() { return a + b + c + d; };
```

Это делает код более читабельным и уменьшает риск забыть захватить нужную переменную.

---

##### Важно помнить

* **`[=, &var]`** означает: всё по значению, кроме `var` — по ссылке.
* **`[&, var]`** означает: всё по ссылке, кроме `var` — по значению.
* Нельзя смешивать правила вразнобой (например, `[=, &a, b]` будет ошибкой).

#### Еще пример:

Необходимо вывести элементы словаря, отсортированные по убыванию суммы значений каждого элемента. Для этого алгоритм сначала должен вычислить сумму значений для каждого ключа, затем отсортировать элементы на основе этих сумм в порядке убывания. Для сортировки удобно использовать функцию sorted(), которая позволяет задать критерий сортировки. В данном случае этот критерий — сумма значений, и его проще всего определить с помощью лямбда-функции.

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <algorithm>
#include <numeric> 

int main() {
    // Инициализация словаря bigrams
    std::map<std::string, std::vector<int>> bigrams = {
        {"AB", {10, 11, 12}},
        {"BC", {5, -5, 8}},
        {"CD", {105, 1, 0}},
        {"DE", {6, 6}},
        {"EF", {15, 20, 15}},
        {"FG", {22, 11, 32}},
        {"GH", {20, 20, 20}}
    };

    // Создаем вектор для ключей
    std::vector<std::pair<std::string, std::vector<int>>> sorter(bigrams.begin(), bigrams.end());

    // Сортировка вектора с помощью лямбды
    std::sort(sorter.begin(), sorter.end(), [](const auto& a, const auto& b) {
        // Суммируем значения в векторах и сравниваем для сортировки по убыванию
        int sumA = std::accumulate(a.second.begin(), a.second.end(), 0);
        int sumB = std::accumulate(b.second.begin(), b.second.end(), 0);
        return sumA > sumB; // Сортировка по убыванию
    });

    // Вывод отсортированного словаря
    for (const auto& pair : sorter) {
        std::cout << pair.first << ": ";
        for (int num : pair.second) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

##### Объяснение:

Используем std::map для хранения исходных данных, где ключи — это строки, а значения — вектора целых чисел.

Для сортировки создаем вектор sorter, куда копируем пары ключ-значение из словаря.

В std::sort передаем лямбду, которая суммирует элементы вектора для каждой пары и сортирует по убыванию суммы.

С помощью std::accumulate из библиотеки numeric суммируются элементы вектора.

#### 3.4 Лямбда-выражения как параметры функций

Лямбда-выражения в C++ — это объекты, которые можно передавать в другие функции. Это делает их очень удобными для написания обобщённых функций, которые принимают «действие» как аргумент.

##### Пример:

```cpp
#include <iostream>
#include <functional>

// Функция, которая принимает любую "вызываемую сущность"
void runTwice(const std::function<void()> &func) {
    func(); // первый вызов
    func(); // второй вызов
}

int main() {
    // Передаём лямбду напрямую
    runTwice([]() {
        std::cout << "Привет из лямбды!" << std::endl;
    });

    return 0;
}
```

##### Объяснение:

* В функции `runTwice` параметр `func` имеет тип `std::function<void()>`, то есть он может хранить любую функцию без параметров и без возвращаемого значения.
* Мы передаём туда лямбду `[]() { ... }`.
* В итоге `runTwice` вызывает её два раза подряд.

Это удобно, когда нужно реализовать обратные вызовы (callbacks) или повторяющиеся действия.

##### Ещё пример: использование в алгоритмах

```cpp
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> nums = {5, 2, 9, 1, 7};

    // Сортируем по убыванию, передав лямбду в std::sort
    std::sort(nums.begin(), nums.end(), [](int a, int b) {
        return a > b;
    });

    for (int n : nums) {
        std::cout << n << " ";
    }
    // Вывод: 9 7 5 2 1
}
```

Здесь лямбда используется как компаратор: мы задали свой способ сравнения элементов при сортировке.


### Заключение

C++17 привносит множество улучшений, которые упрощают написание и поддержку кода, делая его более читаемым, компактным и эффективным. `if constexpr` позволяет писать более оптимизированный код на этапе компиляции, inline-функции и переменные упрощают работу с заголовочными файлами, `auto` автоматизирует вывод типов, а улучшенные лямбда-выражения делают функциональный стиль программирования проще и удобнее.

# Практические задания

Задачи L03-*
